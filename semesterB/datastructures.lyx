#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options false
\language hebrew
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
מבנה נתונים
\end_layout

\begin_layout Author
עפיף חלומה
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
הרצאה מס.
\numeric on
1
\end_layout

\begin_layout Standard
אתר:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
www.cs.huji.ac.il/~dast
\end_layout

\begin_layout Chapter
הרצאה מס.
\numeric on
2
\end_layout

\begin_layout Standard
סיקום של הרצאה קודמת: 
\begin_inset Formula $o,\Theta,\Omega,O$
\end_inset


\end_layout

\begin_layout Enumerate
קבועים בפנים לא משנים
\end_layout

\begin_layout Enumerate
\begin_inset Formula $f\left(n\right)=\overset{O}{\underset{\Theta}{\Omega}}\left(g\left(n\right)+h\left(n\right)\right)=\overset{O}{\underset{\Theta}{\Omega}}\left(g\left(n\right)\right)$
\end_inset

 כלומר 
\begin_inset Formula $h\left(n\right)$
\end_inset

 זניח יחסית ל 
\begin_inset Formula $g\left(n\right)$
\end_inset

 אז אפשר להשמיט את 
\begin_inset Formula $h\left(n\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $f\left(n\right)=n^{d},g\left(n\right)=c^{n}$
\end_inset

 אזי 
\begin_inset Formula $g\left(n\right)$
\end_inset

 מנצח את 
\begin_inset Formula $f\left(n\right)$
\end_inset

.
 
\begin_inset Formula $f\left(n\right)=O\left(g\left(n\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $f\left(n\right)=\log^{c}\left(n\right),g\left(n\right)=n^{d}$
\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout
כאשר אומרים 
\begin_inset Formula $\log$
\end_inset

 מתקוונים ל
\begin_inset Formula $\log_{2}$
\end_inset

 שהוא שווה ל
\begin_inset Formula $\log_{10}$
\end_inset

 עד כדי קבוע
\end_layout

\end_inset

 אזי 
\begin_inset Formula $g\left(n\right)$
\end_inset

 מנצח את 
\begin_inset Formula $f\left(n\right)$
\end_inset

.
 
\end_layout

\begin_layout Section
מיון בועות
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
Bubble Sort A[1...n] {
\end_layout

\begin_layout Plain Layout

\lang english
if n>1 {
\end_layout

\begin_layout Plain Layout

\lang english
bubble(A[1...n])
\end_layout

\begin_layout Plain Layout

\lang english
bubblesort(A[1,...,n-1])
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
Bubble(A[1...n]) {
\end_layout

\begin_layout Plain Layout

\lang english
for j=1 to n-1 {
\end_layout

\begin_layout Plain Layout

\lang english
if A(j)>A(j+1) then swap
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\lang hebrew

\begin_inset Caption

\begin_layout Plain Layout

\lang english
Bubble Sort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
סיבוכיות של 
\begin_inset Formula $Bubble$
\end_inset

 היא .
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & = & T\left(n-1\right)+\Theta\left(n\right)\\
T\left(1\right) & = & \Theta\left(1\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
נרצה לפתור את הבעיה הזו ולנצל את זה לראות כל מיני שיטות לפתור בעיות ריקורסיה.
\end_layout

\begin_layout Subsection
השיטה האיטרטיבית
\end_layout

\begin_layout Standard
זה פשוט "לא יודעים אז בואו ננסה" 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & \leq & T\left(n-1\right)+c\cdot n\\
 & \leq & T\left(n-2\right)+c\left(n-1\right)+cn\\
 & \leq & T\left(n-3\right)+c\left(n-2\right)+c\left(n-1\right)+cn\\
 & \leq & T\left(1\right)+2c+3c+\dots+c\left(n-1\right)+cn\\
 & \leq & T\left(1\right)+\sum_{i=2}^{n}c\cdot i\\
 & = & T\left(1\right)+c\left(\frac{n\left(n-1\right)}{2}-1\right)\\
 & = & O\left(n^{2}\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
מאותו שיקול
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & \geq & T\left(n-1\right)+c^{\prime}n\\
 &  & \vdots\\
 & \geq & \Theta\left(n^{2}\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
מסיקים כי 
\begin_inset Formula $T\left(n\right)=\Omega\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
לכן 
\begin_inset Formula $T\left(n\right)$
\end_inset

 הוא גם 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 וגם 
\begin_inset Formula $\Omega\left(n^{2}\right)$
\end_inset

 ולכן 
\begin_inset Formula $T\left(n\right)=\Theta\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Section
שיטת הניחוש וההוכחה באינדוקציה
\end_layout

\begin_layout Standard
ננסה להוכיח באינדוקציה 
\begin_inset Formula $T\left(n\right)\leq cn^{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & = & T\left(n-1\right)+\Theta\left(n\right),\Theta\left(n\right)\leq cn\\
T\left(1\right) & = & \Theta\left(1\right)\leq c\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
עבור 
\begin_inset Formula $n=1$
\end_inset

: 
\begin_inset Formula $T\left(1\right)\leq c$
\end_inset

 בסדר.
\end_layout

\begin_layout Standard
נניח עבור 
\begin_inset Formula $n$
\end_inset

 ש 
\begin_inset Formula $T\left(n\right)\leq cn^{2}$
\end_inset


\end_layout

\begin_layout Standard
נוכיח עבור 
\begin_inset Formula $n+1$
\end_inset

 כי 
\begin_inset Formula $T\left(n+1\right)=T\left(n\right)+c\left(n+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n+1\right) & = & T\left(n\right)+c\left(n+1\right)\\
 & \overset{\mbox{\R{מהנחת\,האינדוקציה}}}{\leq} & cn^{2}+c\left(n+1\right)\\
 & = & c\left(n^{2}+n+1\right)\\
 & \leq & c\left(n+1\right)^{2}\end{eqnarray*}

\end_inset

 
\end_layout

\begin_layout Standard
זה מראה כי 
\begin_inset Formula $T\left(n\right)=O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
באותה צירה אפשר להוכיח הצד השני של האינדוקציה
\end_layout

\begin_layout Section
מיון מיזוג -
\family roman
\series bold
\shape up
\size larger
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Merge Sort
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
Merge Sort(A[1...n]){
\end_layout

\begin_layout Plain Layout

\lang english
if n>1 {
\end_layout

\begin_layout Plain Layout

\lang english
mergesort(A[1...
\begin_inset Formula $\nicefrac{n}{2}$
\end_inset

])
\end_layout

\begin_layout Plain Layout

\lang english
mergesort(A[
\begin_inset Formula $\nicefrac{n}{2}+1$
\end_inset

...n])
\end_layout

\begin_layout Plain Layout

\lang english
merge(A[1,...
\begin_inset Formula $\nicefrac{n}{2}$
\end_inset

],A[
\begin_inset Formula $\nicefrac{n}{2}+1$
\end_inset

...n],A[1...n])
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
Merge(A,B,C) {
\end_layout

\begin_layout Plain Layout

\lang english
l=1,i=1,j=1
\end_layout

\begin_layout Plain Layout

\lang english
do while i<
\begin_inset Formula $\nicefrac{n}{2}$
\end_inset

 or j<
\begin_inset Formula $\nicefrac{n}{2}$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
c[l]=min(A[i],B[i])
\end_layout

\begin_layout Plain Layout

\lang english
if min was A(i) increment i, else incrememnt j
\end_layout

\begin_layout Plain Layout

\lang english
increment l
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
Merge Sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
עץ הרקורסיה:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c2d1.svg
	lyxscale 20
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
עץ הריקורסיה של מיון מיזזוג
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
נבנה עכשיו את עץ הריקורסיה ונכתוב כמה פעולות קוראות בכל קודקוד.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c2d2.svg
	lyxscale 20
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
משקל כל קודקוד במיזוג מיון
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
ניתן לראות כי בכל שורה בעץ יש 
\begin_inset Formula $cn$
\end_inset

 פעולות.
 אזי האלגורתם הזה עולה 
\begin_inset Formula $cn\cdot\left(\mbox{\R{גובה\,העץ}}\right)=cn\cdot\log_{2}\left(n\right)$
\end_inset


\end_layout

\begin_layout Section
סיבוכיות של אלגורתם אלפרדו משהוא
\end_layout

\begin_layout Standard
\begin_inset Formula \[
T\left(n\right)=aT\left(\nicefrac{n}{b}\right)+\Theta\left(n^{k}\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c2d3.svg
	lyxscale 20
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
עץ קריאה של אלגוריתם אלפרדו
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $m=\log_{b}n$
\end_inset

 אזי מספר השורות הוא 
\begin_inset Formula $m+1$
\end_inset


\end_layout

\begin_layout Standard
העבודה בשורה העליונה היא 
\begin_inset Formula $\Theta\left(cn^{k}\right)$
\end_inset


\end_layout

\begin_layout Standard
העבודה השורה התחתונה היא 
\begin_inset Formula $\Theta\left(a^{\log_{b}n}\right)$
\end_inset


\end_layout

\begin_layout Standard
אזי
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & \leq & cn^{k}\sum_{l=0}^{m}\left(\underbrace{\frac{a}{b^{k}}}_{k}\right)^{l}\\
 & \leq & cn^{k}\left(\frac{q^{m+1}-1}{q-1}\right)=cn^{k}\left(\frac{1-q^{m+1}}{1-q}\right)=cn^{k}\left(\frac{1-q^{m+1}}{1-q}\right)\\
 & \underbrace{\leq}_{q<1} & cn^{k}\frac{1}{q-1}=O\left(n^{k}\right)\\
T & = & O\left(n^{k}\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
מה אם 
\begin_inset Formula $q=1$
\end_inset

 כמו ב
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
merge sort
\lang hebrew
?
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & \leq & cn^{k}\left(m+1\right)\\
 & = & cn^{k}\left(\log_{b}\left(n+1\right)\right)\\
 & = & \Theta\left(n^{k}\log n\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
מה אם 
\begin_inset Formula $q>1$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(n\right) & \leq & cn^{k}\frac{q^{m+1}-1}{q-1}\\
 & = & \Theta\left(n^{k}q^{m}\right)\\
 & = & \Theta\left(n^{k}\left(\frac{a}{b^{k}}\right)^{m}\right)\\
 & = & \Theta\left(n^{k}\frac{a^{m}}{a^{mk}}\right)\\
 & \underbrace{=}_{b^{m}=n} & \Theta\left(a^{m}\right)\\
 & = & \Theta\left(a^{\log_{b}n}\right)\\
 & \underbrace{=}_{\mbox{\R{תרגיל}}} & \Theta\left(n^{\log_{b}a}\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Chapter
תרגול מס.
\numeric on
2
\end_layout

\begin_layout Standard
מעריכים אלגוריתם לפי זמן ריצה וכמה מקום הוא לוקח בזכרון, מתארים את זה דרך
 פונקציות 
\begin_inset Formula $\mathcal{O},\theta,\Omega$
\end_inset


\end_layout

\begin_layout Section
שיטות לפתור ריקורסיה
\end_layout

\begin_layout Enumerate
שיטה איטרטיבית
\end_layout

\begin_layout Enumerate
לנחש ולהוכיח באינדוקציה
\end_layout

\begin_layout Enumerate
עץ ריקורסיה
\end_layout

\begin_layout Enumerate
משפט המאסתר -
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Master Theorem
\end_layout

\begin_layout Enumerate
לחסום מלמעלה ומלמטה על ידי פומקציה אחרת
\end_layout

\begin_layout Subsection
שיטת עץ הריקורסיה
\end_layout

\begin_layout Standard
משתמשים בזה לנחש את הפתרון
\end_layout

\begin_layout Standard
אחרי שמנחשים צריך להוכיח
\end_layout

\begin_layout Standard
למשל, תמצא חסם עליון על 
\begin_inset Formula $T\left(1\right)=6,T\left(2\right)=7,T\left(3\right)=10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
T\left(1\right) & = & 6,T\left(2\right)=7,T\left(3\right)=10\\
T\left(n\right) & = & T\left(\frac{n}{3}\right)+T\left(\frac{2n}{3}\right)+\Theta\left(n\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
את 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 נכתוב בצורת 
\begin_inset Formula $cn$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c3d1.svg
	lyxscale 30
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
דוגמה לעץ ריצה
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
אפשר לראות כי בכל שורה יש 
\begin_inset Formula $cn$
\end_inset

 פעולות.
 אבל זה לא בדיוק נכון כי הענף הימני ארוך יותר מהענף השמאלי.
\end_layout

\begin_layout Standard
הגובה המקסימאלי של עץ זה הוא 
\begin_inset Formula $h=\log_{\nicefrac{3}{2}}\left(n\right)$
\end_inset


\end_layout

\begin_layout Standard
אזי נרצה להוכיח כי 
\begin_inset Formula $cn\log_{\nicefrac{3}{2}}n=\mathcal{O}\left(n\log n\right)$
\end_inset


\end_layout

\begin_layout Chapter
הרצאה מס.
\numeric on
3
\end_layout

\begin_layout Section
אלגוריתם
\family roman
\series bold
\shape up
\size larger
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Quicksort
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
Quicksort
\begin_inset Formula $\left[Left,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--if(
\begin_inset Formula $right$
\end_inset

>
\begin_inset Formula $left$
\end_inset

)
\end_layout

\begin_layout Plain Layout

\lang english
----
\begin_inset Formula $m$
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset

partition
\begin_inset Formula $\left[A,Left,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----Quckisort
\begin_inset Formula $A\left[Left,m-1\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----Quicksort
\begin_inset Formula $A\left[m+1,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
Partition 
\begin_inset Formula $A\left[Left,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--If 
\begin_inset Formula $Left<Right$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----
\begin_inset Formula $L=Left,R=Right,pivot=A\left(Right\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----for 
\begin_inset Formula $j=Left$
\end_inset

 to 
\begin_inset Formula $Right$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
------if 
\begin_inset Formula $A\left(j\right)<pivot$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--------
\begin_inset Formula $B\left(L\right)=A\left(j\right),L++$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
------else
\end_layout

\begin_layout Plain Layout

\lang english
--------
\begin_inset Formula $B\left(R\right)=A\left(j\right),R--$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----
\begin_inset Formula $B\left(L\right)=A\left[Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----
\begin_inset Formula $A\left[Left,Right\right]=B\left[Left,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
----return 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
Quicksort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
יש גרסה יותר יעילה לפונקציה 
\begin_inset Formula $Partition$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
Partition In Place 
\begin_inset Formula $A\left[Left,Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--
\begin_inset Formula $pivot=A\left[Right\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--scan A from Left to find A
\begin_inset Formula $\left(j\right)>pivot$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--scan B from Right to find A
\begin_inset Formula $\left(j\right)<pivot$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
--Swap
\end_layout

\begin_layout Plain Layout

\lang english
--continue until pointers cross
\end_layout

\begin_layout Plain Layout

\lang english
--swap pivot with that location(where pointers cross)
\end_layout

\begin_layout Plain Layout

\lang english
--return pointer
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
Partition In Place
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
אז רוצים לנתח את 
\begin_inset Formula $Quicksort$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
T\left(n\right)=T\left(m-1\right)+T\left(n-m\right)+\Theta\left(n\right)\]

\end_inset


\end_layout

\begin_layout Standard
אבל את כל זה תלוי ב 
\begin_inset Formula $m$
\end_inset

 שאי אפשר לבטא אותו באופן חד חד ערכי.
 אז נסתכל על כמה מקרי קיצון:
\end_layout

\begin_layout Enumerate
אם 
\begin_inset Formula $m=n-1$
\end_inset

 תמיד מקבלים 
\begin_inset Formula $T\left(n\right)=T\left(n-2\right)+T\left(1\right)+\theta\left(n\right)$
\end_inset

 ועומק הריקורסיה הוא 
\begin_inset Formula $n$
\end_inset

 אזי 
\begin_inset Formula $T\left(n\right)=\Theta\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
אם 
\begin_inset Formula $m=\frac{n}{2}$
\end_inset

 תמיד מקבלים 
\begin_inset Formula $T\left(n\right)=T\left(\frac{n}{2}-1\right)+T\left(\frac{n}{2}\right)+\Theta\left(n\right)$
\end_inset

 אזי 
\begin_inset Formula $T\left(n\right)=\Theta\left(n\log n\right)$
\end_inset

 כמו
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Mergesort
\lang hebrew
 
\end_layout

\begin_layout Enumerate
נניח 
\begin_inset Formula $m=\frac{9}{10}m$
\end_inset

 אזי מקבלים 
\begin_inset Formula $T\left(n\right)=T\left(\frac{9}{10}n\right)+T\left(\frac{n}{10}\right)+\Theta\left(n\right)$
\end_inset

 אזי העומק המקסימאלי הוא 
\begin_inset Formula $\log_{\nicefrac{10}{9}}n=\frac{\log_{2}n}{\log_{2}\frac{10}{9}}$
\end_inset

 אבל הרבה ענפים נפסקים באמצע אזי מקבלים כי זה 
\begin_inset Formula $\mathcal{O}\left(n\log n\right)$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
שים לב, זה 
\begin_inset Formula $\mathcal{O}$
\end_inset

 ולא 
\begin_inset Formula $\Theta$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
טענה: 
\end_layout

\begin_layout Standard
לכל קלט 
\begin_inset Formula $T\left(n\right)=\mathcal{O}\left(n^{2}\right)$
\end_inset

 וכן 
\begin_inset Formula $T\left(n\right)=\Omega\left(n\log n\right)$
\end_inset


\end_layout

\begin_layout Standard
הקלט האכי גרוע הוא מערך ממיון וסיבוכיות של
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Worst Case
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 של 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Quicksort
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
הוא 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Subsection
סיבוכיות ממוצעת
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left\langle T\left(n\right)\right\rangle =\sum_{\delta}\frac{\left(T\left(n\right)\, for\, input\,\delta\right)}{n!}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\delta$
\end_inset

 הוא מיון מסויים של המספרים 
\begin_inset Formula $\left\{ k_{1},\dots,k_{n}\right\} $
\end_inset


\end_layout

\begin_layout Standard
מקבלים כי 
\begin_inset Formula $\left\langle T\left(n\right)\right\rangle =\Theta\left(n\log n\right)$
\end_inset

 אבל את זה לא נוכיח
\end_layout

\begin_layout Standard
דרך אחרת לחשב התוכלת היא להגריל את 
\begin_inset Formula $m$
\end_inset

 שזה די נכון לעשות ואז נחשב את התוחלת 
\begin_inset Formula $E\left(T\left(n\right)\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
E\left(T\left(n\right)\right)=\sum_{m=1}^{n}\frac{1}{n}\Biggl(E\Bigl(T\left(m-1\right)\Bigr)+E\Bigl(T\left(n-m\right)\Bigr)\Biggr)+\Theta\left(n\right)\]

\end_inset

 
\end_layout

\begin_layout Chapter
הרצאה מס.
\numeric on
4
\end_layout

\begin_layout Standard
התוכלת של
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Randomized Quicksort
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
היא
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
E\left(T\left(n\right)\right) & = & \sum_{m=1}^{n}\frac{1}{n}\Biggl(E\Bigl(T\left(m-1\right)\Bigr)+E\Bigl(T\left(n-m\right)\Bigr)\Biggr)+\Theta\left(n\right)\\
 & = & \sum_{m=0}^{n-1}\frac{1}{n}\cdot2\cdot E\left(T\left(m\right)\right)+\Theta\left(n\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
בקורס זה תמיד 
\begin_inset Formula $T\left(1\right)=\mathcal{\Theta}\left(1\right)$
\end_inset

 אזי
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\sum_{m=0}^{n-1}\frac{2}{n}E\left(T\left(m\right)\right)+c_{2}n & \leq & E\left(T\left(n\right)\right)\leq\sum_{m=0}^{n-1}\frac{2}{n}E\left(T\left(m\right)\right)+c_{1}n\\
c_{2}\leq & E\left(T\left(1\right)\right) & \leq c_{1}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
אז נגדיר 
\begin_inset Formula \begin{eqnarray*}
U_{C}\left(n\right) & = & \sum_{m=0}^{n-1}\frac{2}{n}U_{c}\left(m\right)+cn\\
U_{c}\left(1\right) & = & U_{c}\left(0\right)=c\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
טענה:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
U_{c_{2}}\leq E\left(T\left(n\right)\right)\leq U_{c_{1}}\left(n\right)\]

\end_inset


\end_layout

\begin_layout Standard
ניתן להוכיח באינדוקציה)ההוכחה בתרגיל(
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
 & =\\
 & =\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
-\left\{ \begin{array}{rcl}
nU_{c}\left(n\right) & = & 2\sum_{m=0}^{n-1}U_{c}\left(m\right)+cn^{2}\\
\left(n+1\right)U_{c}\left(n+1\right) & = & 2\sum_{m=0}^{n}U_{c}\left(m\right)+c\left(n+1\right)^{2}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\left(n+1\right)U_{c}\left(n+1\right)-nU_{c}\left(n\right) & = & 2U_{c}\left(n\right)+c\left(n+1\right)^{2}-cn^{2}\\
\left(n+1\right)U_{c}\left(n+1\right) & = & \left(n+2\right)U_{c}\left(n\right)+2cn+c\\
U_{c}\left(n+1\right) & = & \frac{n+2}{n+1}U_{c}\left(n\right)+\frac{2cn+c}{n+1}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
טענה קלה: 
\begin_inset Formula \[
c\leq\frac{2cn+c}{n+1}\leq2c\]

\end_inset


\end_layout

\begin_layout Standard
אזי
\end_layout

\begin_layout Standard
\begin_inset Formula \[
U_{c}\left(n+1\right)\leq\frac{n+2}{n+1}U_{c}\left(n\right)+2c\]

\end_inset


\end_layout

\begin_layout Standard
נפתור את זה בשיטת האיטרציה:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
U_{c}\left(n+1\right) & \leq & \frac{n+2}{n+1}\left(\frac{n+1}{n}u_{c}\left(n-1\right)+2c\right)+2c\\
 & = & \frac{n+2}{n+1}\cdot\frac{n+1}{n}U_{c}\left(n-1\right)+\frac{n+2}{n+1}\cdot2c+\frac{n+2}{n+2}\cdot2c\\
 & \leq & \frac{n+2}{n+1}\cdot\frac{n+1}{n}\left(\frac{n}{n-1}U_{c}\left(n-2\right)+2c\right)+\frac{n+2}{n+1}+\frac{n+2}{n+2}2c\\
 & \leq & \frac{n+2}{n+2}\cdot2c+\frac{n+2}{n+1}\cdot2c+\frac{n+2}{n}+2c+\frac{n+2}{n+1}\cdot\frac{n+1}{n}\left(\frac{n}{n-1}U_{c}\left(n-2\right)+2c\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
רואים כי כל כופלי 
\begin_inset Formula $U_{C}\left(\dots\right)$
\end_inset

 מצתמצמים ונשאר המונה הראשון והמכנה האחרון אזי
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
U_{c}\left(n+1\right) & \leq & \left(n+2\right)2c\sum_{j=1}^{n+2}\frac{1}{j}+\left(n+2\right)\cdot2c\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Chapter
הרצאה מס.?
\end_layout

\begin_layout Standard
השיעורים הקודמים היו סתם הכנה למתמטיקה.
 היום נכנס למבנה הנתונים.
\end_layout

\begin_layout Standard
סוג נתונים אבסטרקטי
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\mbox{Abstract Data Type}$
\end_inset


\end_layout

\end_inset

 הוא אוסף נתונים + פעולות.
 דוגמעות
\end_layout

\begin_layout Itemize
מחסנית:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
push, pop LIFO
\end_layout

\begin_layout Itemize
תור:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
enqueue, dequeue FIFO
\end_layout

\begin_layout Section
תור קדימיות
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\mbox{Priority Queue}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
קיימים שתי סוגים של תור זה:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Min Priority Queue}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Max Priority Queue}$
\end_inset


\end_layout

\begin_layout Standard
פעולות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $max\left(S\right)$
\end_inset

 מחזירה רשומה עם ערך קדימות הכי גבוה.
\end_layout

\begin_layout Itemize
\begin_inset Formula $extract-max\left(S\right)$
\end_inset

 אותו דבר אבל עם הוצאת הרשומה מהתור.
\end_layout

\begin_layout Itemize
\begin_inset Formula $insert\left(S,x\right)$
\end_inset

 מכניסה לתור רשומה עם קדימות 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $increase\_key\left(S,i,key\right)$
\end_inset

 מעלה את קדימות של האיבר ה
\begin_inset Formula $i$
\end_inset

 בתור ל
\begin_inset Formula $key$
\end_inset


\end_layout

\begin_layout Subsection
מימוש בעזרת ערימה
\end_layout

\begin_layout Standard
ערימה זו עץ קמעט שלם שמקיים תכונת הערימה כלומר: 
\begin_inset Formula $\forall i:A\left[parent\left(i\right)\right]\geq A\left(i\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c6d1.svg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
עץ קמעט שלם עם הצגתו במערך
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
במערך של העץ מתקיים:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
left\left(i\right) & = & 2i\\
right\left(i\right) & = & 2i+4\\
parent\left(i\right) & = & \left\lfloor \frac{i}{2}\right\rfloor \end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
רוצים לממש את הפעולות של ה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
ADT
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
של תור הקדימות כך שמבנה הערימה ישמר.
\end_layout

\begin_layout Standard
אז נממש את הפעולות שהגדרנו:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
max
\begin_inset Formula $\left(S\right)$
\end_inset

{
\end_layout

\begin_layout Plain Layout

\lang english
return A
\begin_inset Formula $\left(1\right)$
\end_inset

;
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
extract-max
\begin_inset Formula $\left(S\right)$
\end_inset

{
\end_layout

\begin_layout Plain Layout

\lang english
max=S
\begin_inset Formula $\left(1\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
swap
\begin_inset Formula $\left(min\left(S\right),S\left(1\right)\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
heapsize--;
\end_layout

\begin_layout Plain Layout

\lang english
max_heapify(A,1);
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
min
\begin_inset Formula $\left(S\right)$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
return 
\begin_inset Formula $S\left[heapsize\left(S\right)\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
max_heapify(A,i) {
\end_layout

\begin_layout Plain Layout

\lang english
l=left
\begin_inset Formula $\left(i\right)$
\end_inset

;
\end_layout

\begin_layout Plain Layout

\lang english
r=right
\begin_inset Formula $\left(i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(l\leq heapsize\left[A\right]\right)$
\end_inset

 then {
\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(r>heapsize\left[A\right]\right)$
\end_inset

 then r=reapsize
\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(A\left(l\right)>A\left(i\right)\right)$
\end_inset

 largest=l, else largest=i
\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(A\left(r\right)>A\left(largest\right)\right)$
\end_inset

 largest=r
\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(largest\neq i\right)$
\end_inset

 then swap 
\begin_inset Formula $\left(A\left[largest\right],A\left[i\right]\right)$
\end_inset

, max_heapify(A,largest)
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
פעולת 
\begin_inset Formula $extract\_max\left(S\right)$
\end_inset

 בערימת קדימות
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
הסיבוכיות של
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
maxheapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
היא 
\begin_inset Formula $\mathcal{O}\left(D\right)=\mathcal{O}\left(\log n\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
increase_key
\begin_inset Formula $\left(A,i,key\right)$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
if
\begin_inset Formula $\left(key<A\left[i\right]\right)$
\end_inset

 error 
\begin_inset Quotes eld
\end_inset

new key smaller than old
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
A
\begin_inset Formula $\left(i\right)$
\end_inset

=key
\end_layout

\begin_layout Plain Layout

\lang english
while i>1 and A
\begin_inset Formula $\left[parent\left(i\right)\right]<A\left[i\right]$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
swap
\begin_inset Formula $\left(A\left[i\right],A\left[parent\left(i\right)\right]\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
i=parent
\begin_inset Formula $\left(i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
פעולת 
\begin_inset Formula $increase\_key\left(A,i,key\right)$
\end_inset

 בערימת קדימות
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
סיבוכיות של פעולה זו היא גם 
\begin_inset Formula $\mathcal{O}\left(\log n\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
heapsize
\begin_inset Formula $\left(a\right)$
\end_inset

++
\end_layout

\begin_layout Plain Layout

\lang english
A
\begin_inset Formula $\left(heapsize\left(A\right)\right)=-\infty$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
increase_key
\begin_inset Formula $\left[A,heapsize\left(A\right),key\right]$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
פעולת 
\begin_inset Formula $\mbox{insert}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
איך מייצרים ערימה?
\end_layout

\begin_layout Standard
יש כל מיני פתרונות שעובדות ב 
\begin_inset Formula $\mathcal{O}\left(n\log n\right)$
\end_inset

 אבל יש גם דרך לעשות את זה ב
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
build_heap
\begin_inset Formula $\left(A\right)$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
heapsize
\begin_inset Formula $\left[A\right]$
\end_inset

=length
\begin_inset Formula $\left[A\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
for(i=n to 1) max_heapify(A,i)
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
בנית ערימה
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
זה נראה כמו 
\begin_inset Formula $\mathcal{O}\left(n\log n\right)$
\end_inset

 אבל באמת זה יוצא 
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset


\end_layout

\begin_layout Standard
האלגוריתם הזה עובד כי:
\end_layout

\begin_layout Enumerate
כל שורש בקודקוד בערימת מקסימום זה שורש של ערימת מקסימום.
\end_layout

\begin_layout Enumerate
כל קודקוד בעץ כמעט שלם הוא שורש של עץ קמעט שלם
\end_layout

\begin_layout Enumerate
אם מפעילים
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
על קודקוד 
\begin_inset Formula $i$
\end_inset

 ששני בניו שורשי ערימות מקסימום אזי 
\begin_inset Formula $i$
\end_inset

 יהיה שורש של ערימת מקסימום
\end_layout

\begin_layout Chapter
הרצאה מס.?
\end_layout

\begin_layout Standard
ערמה זה עץ כמעט שלם
\end_layout

\begin_layout Standard
כל קודקוד גדול אושווה לבניו.
\end_layout

\begin_layout Standard
נרצה לכתוב את האלגוריתם לבנות ערמה חדשה ממערך
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
buildHeap
\begin_inset Formula $\left(A\right)$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
n=length
\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
for i=n to 1 do{
\end_layout

\begin_layout Plain Layout

\lang english
max_heapify
\begin_inset Formula $\left(A,i\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
בנית ערימה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
BuildHeap
\begin_inset Formula $\left(A\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
נרצה עכשיו לראות למה זה עובד ומה הזמן ריצה של זה.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
זאת הבעיה הראשונה שאנחנו נוכיח כי היא עובדת.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
הדרך להוכיח את זה הוא דרך אינדוקציה.
\end_layout

\begin_layout Standard
אינטואיציה: האלגוריתם כל פעם מתקן הערימה הקטנה שיש לו ומתחיל מהסוף עד להתחלה.
 אז כל פעם שאנחנו מפעילים
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
יש לנו כבר שתי תתי ערימות תקינות שמחוברים לקודקוד שאנחנו מפעילים אותה עליו(
\end_layout

\begin_layout Paragraph
הוכחה פורמלית:
\end_layout

\begin_layout Standard
נשתמש במשהוא שנקרא
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Loop Invariant
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
שיש לו שלוש תכונות:
\end_layout

\begin_layout Enumerate
קודקוד בעץ כמעט שלם הוא שורש של עץ כמעט שלם.
\end_layout

\begin_layout Enumerate
קודקוד בערימת מקסימום הוא שורש של ערימת מקסימום.
\end_layout

\begin_layout Enumerate
אם מריצים
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
על קודקוד שבניו הם ערימת מקסימום אז מתקבלת ערימת מקסימום.
\end_layout

\begin_layout Standard
בשלו ה
\lang english
i
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 הקודקודים 
\begin_inset Formula $n,n-1\dots n-i+1$
\end_inset

 הם שורשים של ערימת מקסימום
\end_layout

\begin_layout Paragraph
הוכחה:
\end_layout

\begin_layout Subparagraph
בסיס אינדוקציה:
\end_layout

\begin_layout Standard
עבור בסיס 
\begin_inset Formula $k=1$
\end_inset

 זה טריוויאלי כי כל עלה הוא כבר ערימת מקסימום.
\end_layout

\begin_layout Subparagraph
הנחת האינדוקציה: 
\end_layout

\begin_layout Standard
\begin_inset Formula $n,n-1\dots n-k+1$
\end_inset

 הם שורשים לערימת מקסימום.
\end_layout

\begin_layout Subparagraph
היכחה עבור 
\begin_inset Formula $k+1$
\end_inset

:
\end_layout

\begin_layout Standard
לפי הנחת האנדוקציה 
\begin_inset Formula $left\left(n-k\right),right\left(n-k\right)$
\end_inset

)כי האינקסים האילו יותר גדולים מ
\begin_inset Formula $n-k$
\end_inset

( הם ערימות מקסימום.
 לכן מותר לבצע
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\lang hebrew
.
 לכן אחרי הפעלת
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
על 
\begin_inset Formula $n-k$
\end_inset

 הוא נהפך שורש של ערימת מקסימום.
 ולפי ההנחה כל תת-עץ הוא גם ערימת מקסימום.
 זה מה שרוצים להוכיח.
\end_layout

\begin_layout Section
זמן ריצה של
\family roman
\series bold
\shape up
\size larger
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Max_Heapify
\end_layout

\begin_layout Standard
יודעים כבר כי
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
max_heapify
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
הוא רץ בסיבוכיות זמן 
\begin_inset Formula $\mathcal{O}\left(\log n\right)$
\end_inset

.
 אבל זה זמן ריצה מקסימאלי)
\begin_inset Formula $\mathcal{O}\left(\log n\right)$
\end_inset

 ולא 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

( אז נרשום ביטוי יותר מדויק: מסמנים עימק העץ ב 
\begin_inset Formula $D$
\end_inset

 אז ברמה הראשונה)השורש( יש 
\begin_inset Formula $D$
\end_inset

 פעולות.
 ברמה השניה יש לכל קודקוד 
\begin_inset Formula $D-1$
\end_inset

 פעולות אזי 
\begin_inset Formula $2^{1}\left(D-1\right)$
\end_inset

.
 הביטוי הכללי עבור כל רמה 
\begin_inset Formula $d$
\end_inset

 הוא 
\begin_inset Formula $\left(D-d\right)2^{d}=h2^{D-h}$
\end_inset

.
 אזי
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sum_{n=1}^{D}h\cdot2^{D-h}=2^{D}\sum_{h=1}^{d}h2^{-h}=2^{D}\sum_{h=1}^{d}h\left(\frac{1}{2}\right)^{-h}\]

\end_inset


\end_layout

\begin_layout Standard
יודעים כי אם 
\begin_inset Formula $x\in\left(0,1\right)$
\end_inset

 אזי 
\begin_inset Formula $\lim_{h\to\infty}\sqrt{x}^{h}=0$
\end_inset

 אז קיים 
\begin_inset Formula $k^{\prime}$
\end_inset

 כך שבו מתקיים 
\begin_inset Formula $\sqrt{x}^{k^{\prime}}=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\sum_{k=1}^{\infty}kx^{k} & = & \sum_{k=1}^{k^{\prime}}kx^{k}+\sum_{k=k^{\prime}+1}^{\infty}kx^{k}\\
 & = & C+\sum_{k=k^{\prime}+1}^{\infty}\underbrace{k\sqrt{x}^{k}}_{<1}\sqrt{x}^{k}\\
 & \leq & C+\sum_{k=k^{\prime}+1}^{\infty}1\cdot\sqrt{x}^{k}\\
 & \leq & C+\frac{1}{1-\sqrt{x}}+c\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
שהביטוי הזה תלוי רק ב 
\begin_inset Formula $x$
\end_inset

 שזה במקרה שלנו 
\begin_inset Formula $\left(\frac{1}{2}\right)$
\end_inset


\end_layout

\begin_layout Section
עץ חיפוש בינארי
\end_layout

\begin_layout Standard
עץ בינארי בו עבור כל קודקוד 
\begin_inset Formula $x$
\end_inset

 מתקיים
\end_layout

\begin_layout Itemize
עבור 
\begin_inset Formula $y$
\end_inset

 בתת עץ שמאלי של 
\begin_inset Formula $key\left(y\right)\leq key\left(x\right)$
\end_inset


\end_layout

\begin_layout Itemize
עבור 
\begin_inset Formula $y$
\end_inset

 בתת עץ ימיני של 
\begin_inset Formula $key\left(y\right)>key\left(x\right)$
\end_inset


\end_layout

\begin_layout Standard
רוצים שעץ הזה יתמוך בפעולות הבאות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Insert(T,x)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Remove(T,x)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Search(T,x)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{min(T)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{max(T,x)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Successor(T,x)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{Pre....(T,x)}$
\end_inset


\end_layout

\begin_layout Standard
אז הקל ביותר זה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Max,Min
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 ומחזירים האיבר הימיני ביותר או השמאלי ביותר.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
search(n,x) {
\end_layout

\begin_layout Plain Layout

\lang english
if(key(n)==x || n==null) return n
\end_layout

\begin_layout Plain Layout

\lang english
if(key(n)<x) return search(right(n),x);
\end_layout

\begin_layout Plain Layout

\lang english
else return search(left(n),x);
\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
Search(node,value)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
למצא
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
successor
\lang hebrew
:
\end_layout

\begin_layout Itemize
אם ל 
\begin_inset Formula $x$
\end_inset

 יש בן ימני 
\begin_inset Formula $y$
\end_inset

 אזי 
\begin_inset Formula $\mbox{min(T,y)}$
\end_inset

 עוקב של 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Itemize
אין בן ימיני אזי נעלה בעץ עד שנמצא עץ ש
\begin_inset Formula $x$
\end_inset

 הוא בן ימיני שלו.
\end_layout

\begin_layout Itemize
אם 
\begin_inset Formula $x$
\end_inset

 הוא ה
\begin_inset Formula $\mbox{maximum}$
\end_inset

 
\end_layout

\begin_layout Chapter
הרצאה מס.?
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
Explore
\begin_inset Formula $\left(v\right)$
\end_inset

 {
\end_layout

\begin_layout Plain Layout

\lang english
visited
\begin_inset Formula $\left(v\right)$
\end_inset

=1;
\end_layout

\begin_layout Plain Layout

\lang english
previsit
\begin_inset Formula $\left(v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
for all u,(v,u)
\begin_inset Formula $\in$
\end_inset

E if(visited(u)=0;
\end_layout

\begin_layout Plain Layout

\lang english
eplore
\begin_inset Formula $\left(u\right)$
\end_inset

;
\end_layout

\begin_layout Plain Layout

\lang english
postvisit
\begin_inset Formula $\left(v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
Explore(v)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
טענה:
\end_layout

\begin_layout Standard
הפרוצדורה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
explore
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
מגיע לכל הקודקודים בגרף 
\begin_inset Formula $G$
\end_inset

 שניתן להגיע אלהם מ 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Paragraph
הוכחה:
\end_layout

\begin_layout Standard
נניח כי יש מסלול מקודקוד 
\begin_inset Formula $v$
\end_inset

 לקודקוד 
\begin_inset Formula $z$
\end_inset

: 
\begin_inset Formula $v\to v_{1}\to v_{2}\to\dots\to z$
\end_inset

 אם
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Explore
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
לא הגיע ל
\begin_inset Formula $z$
\end_inset

 יש קודקוד אחרון 
\begin_inset Formula $v_{j}$
\end_inset

 שכן הגיע אליו ולא הגיע ל 
\begin_inset Formula $v_{j+1}$
\end_inset

 וזה לא יתכן כי
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
explore
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
סורקת את כל הכנים של 
\begin_inset Formula $v_{i}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
\begin_inset Formula $\forall v\in V:$
\end_inset

visited
\begin_inset Formula $\left(v\right)=0$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula $\forall v\in V:$
\end_inset

 if visited
\begin_inset Formula $\left(v\right)=0$
\end_inset

, explore
\begin_inset Formula $\left(v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang english
DFS
\begin_inset Formula $\left(G\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
דוגמה:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c8d1.svg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
דוגמה של 
\begin_inset Formula $DFS\left(G\right)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
אזי הפונרציה תעבור על הקודקודים בצירה הבאה)כו מקווקו זה צלע שלא עברה עליהם
 הריקורסיה(:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c8d2.svg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
גרף ריקורסיה
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
סיבוכיות של 
\begin_inset Formula $DFS$
\end_inset

 זה 
\begin_inset Formula $\mathcal{O}\left(\left|E\right|\right)+\mathcal{O}\left(\left|V\right|\right)=\mathcal{O}\left(\left|E\right|+\left|V\right|\right)$
\end_inset


\end_layout

\begin_layout Section
רכיבי קשיורות בגרף לא מכוון
\end_layout

\begin_layout Paragraph
נגדיר
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\mbox{Connected Component}$
\end_inset

 - רכיב קשירות
\end_layout

\end_inset

:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $\mbox{CC}\left(v\right)$
\end_inset

 מחזיר רכיב הקשירות שבו נמצא הקודקוד 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $\mbox{CCNum}$
\end_inset

 יספור רכיבי קשירות.

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
CCNum=0
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
בתחילת
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
DSF
\lang hebrew
.
\end_layout

\begin_layout Standard
בכל פעם ששקוראים ל
\begin_inset Formula $explore$
\end_inset

 בתוך 
\begin_inset Formula $DFS$
\end_inset

 נעסה 
\begin_inset Formula $\mbox{CCNum}\leftarrow\mbox{CCNum}+1$
\end_inset

 ונגדיר הפונקציה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
previsit
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
להיות
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
CC
\begin_inset Formula $\left(v\right)\leftarrow\mbox{CCNum}$
\end_inset


\lang hebrew
.
 זה יגדיר לנו את רכיב הקשירות של כל קודקוד.
\end_layout

\begin_layout Section
גרף מכוון
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename datastructures/c8d3.svg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
דוגמה לגרף מכוון
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
יש כמה סוגים של צלעות בגרף זה:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mbox{Tree Edges}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mbox{Forward Edges}$
\end_inset

: צלע לצאצא לא ישיר בגרף
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mbox{Backedges}$
\end_inset

: צלע שהולכת לאב קדמון בעץ
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mbox{Cross Edges}$
\end_inset

: כל דרך אחר
\end_layout

\begin_layout Subsection
גרף מכוון ללא מעגלים
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
DAG: Directed Acyclic Graph
\end_layout

\begin_layout Standard
נרצה למצא מיון טופולוכי הגרף כזה: שזה סידור של קודקודים כך שלכל צלע 
\begin_inset Formula $v\to w$
\end_inset

, 
\begin_inset Formula $w$
\end_inset

 יופיע אחרי 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Standard
למשל באיור 
\begin_inset Formula $8.3$
\end_inset

 
\begin_inset Formula $A,B,D,C$
\end_inset

 זה מיון טופולוגי אם מוחקים את הצלע 
\begin_inset Formula $CA$
\end_inset


\end_layout

\begin_layout Standard
יש מיון טופולוגי אם"ם אין צלע מסוג
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
Backedge
\end_layout

\begin_layout Subsection
רכיבי קשירות בגרף מכוון
\end_layout

\begin_layout Standard
רכיב קשיורות חזק זה אוסף מקסימאלי של קודקודים כך שלכל זוג קודקודים 
\begin_inset Formula $v,w$
\end_inset

 יש מסלול מ 
\begin_inset Formula $v$
\end_inset

 ל
\begin_inset Formula $w$
\end_inset

 ומ 
\begin_inset Formula $w$
\end_inset

 ל
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
clock=0
\end_layout

\begin_layout Plain Layout

\lang english
previsit
\begin_inset Formula $\left(v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
pre
\begin_inset Formula $\left(v\right)=$
\end_inset

clock
\end_layout

\begin_layout Plain Layout

\lang english
clock=clock+1
\end_layout

\begin_layout Plain Layout

\lang english
postvisit
\begin_inset Formula $\left(v\right)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
post
\begin_inset Formula $\left(v\right)=$
\end_inset

clock
\end_layout

\begin_layout Plain Layout

\lang english
clock=clock+1
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
שעון
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
טענה:
\end_layout

\begin_layout Standard
לכל צלע בגרף 
\begin_inset Formula $DAG$
\end_inset

 
\begin_inset Formula $v\to w$
\end_inset

 מתקיים 
\begin_inset Formula $\mbox{post}\left(v\right)>\mbox{post}\left(w\right)$
\end_inset

 אם נמיין לפי ערכי ה
\begin_inset Formula $post$
\end_inset

 בסדר יורד נקבל מיון טופולוגי של 
\begin_inset Formula $DAG$
\end_inset

.
\numeric on
1
\end_layout

\end_body
\end_document
